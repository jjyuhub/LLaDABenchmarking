name: LLaDA Benchmarking (Windows GPU)

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:  # Allows manual triggering

jobs:
  benchmark:
    runs-on: [self-hosted, Windows, GPU]  # Runs on a local Windows runner with GPU

    steps:
      - name: Set up Python environment
        run: |
          python -m venv venv
          venv\Scripts\activate
          python -m pip install --upgrade pip

      - name: Install dependencies
        run: |
          venv\Scripts\activate
          pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121  # CUDA 12.1
          pip install transformers==4.38.2 numpy

      - name: Clone LLaDA repository
        run: |
          git clone https://github.com/ML-GSAI/LLaDA.git

      - name: Install LLaDA dependencies
        run: |
          venv\Scripts\activate
          pip install -e LLaDA

      - name: Check GPU Availability
        run: |
          venv\Scripts\activate
          python -c "import torch; print(f'CUDA Available: {torch.cuda.is_available()}')"

      - name: Create Python Benchmark Script
        run: |
          New-Item -Path . -Name "benchmark.py" -ItemType "file" -Force
          Set-Content -Path benchmark.py -Value @"
          import time
          import torch
          from transformers import AutoModel, AutoTokenizer

          MODEL_NAME = "GSAI-ML/LLaDA-8B-Base"
          FALLBACK_MODEL = "meta-llama/Llama-2-7b"

          device = 'cuda' if torch.cuda.is_available() else 'cpu'
          print(f"Running on device: {device}")

          try:
              print(f"Loading model: {MODEL_NAME}")
              tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME, trust_remote_code=True, force_download=False, revision="main")
              model = AutoModel.from_pretrained(MODEL_NAME, trust_remote_code=True, force_download=False, revision="main", torch_dtype=torch.bfloat16)
          except RuntimeError as e:
              print(f"Memory error: {e}\nFalling back to smaller model: {FALLBACK_MODEL}")
              tokenizer = AutoTokenizer.from_pretrained(FALLBACK_MODEL, trust_remote_code=True)
              model = AutoModel.from_pretrained(FALLBACK_MODEL, trust_remote_code=True)

          model.to(device)
          model.eval()

          # Define input
          prompt = "Write a Python function to sort a list."
          input_ids = tokenizer(prompt, return_tensors="pt")["input_ids"].to(device)

          # Ensure attention_mask is set to avoid unexpected behavior
          attention_mask = torch.ones_like(input_ids).to(device)  # Since padding is unknown, assume no padding

          # LLaDA-Specific: Use Custom Diffusion-Based Generation
          if "llada" in MODEL_NAME.lower():
              from LLaDA.generate import generate  # Import LLaDA's custom generation function

              start_time = time.time()
              output_ids = generate(model, input_ids, steps=128, gen_length=128, block_length=32, 
                                    temperature=0.0, cfg_scale=0.0, remasking='low_confidence')
              end_time = time.time()

              num_generated_tokens = output_ids.shape[1] - input_ids.shape[1]
          else:
              # Fallback to standard generate() for other models
              start_time = time.time()
              output_ids = model.generate(input_ids, max_length=128, attention_mask=attention_mask)
              end_time = time.time()

              num_generated_tokens = len(output_ids[0]) - len(input_ids[0])

          tokens_per_second = num_generated_tokens / (end_time - start_time)

          # Decode and print output
          output_text = tokenizer.decode(output_ids[0], skip_special_tokens=True)
          print(f"Generated Output:\n{output_text}\n")
          print(f"Tokens Generated: {num_generated_tokens}")
          print(f"Inference Speed: {tokens_per_second:.2f} tokens/sec")
          "@

      - name: Run Benchmarking Script
        run: |
          venv\Scripts\activate
          python benchmark.py
